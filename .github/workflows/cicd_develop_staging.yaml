name: Deploy holoclis to staging[develop]

permissions:
  id-token: write
  contents: read # This is required for actions/checkout@v2

env:
  AWS_REGION: us-west-2
  IAM_ROLE: arn:aws:iam::177635894328:role/Github_role_to_access_ECR
  ECR_REPOSITORY: holo-cli-dev # notice: the same for all cli apps
  #
  DEV_IMAGE_TAG: dev-${{ github.sha }}
  #
  CLUSTER_NAME: staging
  #
  AWS_KEY_ID: ${{ secrets.NEWSTAGE_USER_AWS_ACCESS_KEY_ID }}
  AWS_ACCESS_KEY: ${{ secrets.NEWSTAGE_USER_AWS_SECRET_ACCESS_KEY }}
  ALB_CERT_ARN: ${{ secrets.STG_ALB_CERT_ARN_FOR_CXIPCHAIN_XYZ }}
  #
  STG_HOLOGRAPH_INDEXER_OPERATOR_API_KEY: ${{ secrets.HOLO_INDEXER_OPERATOR_API_KEY }}
  #
  STG_HOLOGRAPH_INDEXER_HOST: 'http://devel-holo-api.develop.svc.cluster.local:443'
  #
  STG_HOLOGRAPH_INDEXER_PASSWORD: ${{ secrets.DEV_HOLO_INDEXER_PASSWORD }}
  STG_HOLOGRAPH_OPERATOR_PASSWORD: ${{ secrets.DEV_HOLO_OPERATOR_PASSWORD }}
  #
  # set the RPC endpoints config files
  INDEXER_HOLOGRAPH_CONFIG_FILE_DATA: dev-config-file
  OPERATOR_HOLOGRAPH_CONFIG_FILE_DATA: dev-config-file
  #
  HOLOGRAPH_ENVIRONMENT: develop
  #
  STG_DOMAIN: 'cxipchain.xyz'
  #
  STG_COMMON_NAMESPACE: testholo # NOTICE <---
  #
  #######################################
  STG_HOLOGRAPH_INDEXER_HELM_CHART_VERSION: 0.0.68
  INDEXER_RELEASE_NAME: test-indexer-dev  # format -> [release_name]-indexer-[env]
  #
  STG_HOLOGRAPH_OPERATOR_HELM_CHART_VERSION: 0.0.54
  OPERATOR_RELEASE_NAME: test-operator-dev # format -> [release_name]-operator-[env]
  #######################################
  #
  # INDEXER DEV rpc endpoints
  indexer_dev_avalancheTestnet_rpc_url: ${{ secrets.INDEXER_DEV_FUJI_RPC_URL }}
  indexer_dev_polygonTestnet_rpc_url: ${{ secrets.INDEXER_DEV_MUMBAI_RPC_URL }}
  indexer_dev_ethereumTestnetGoerli_rpc_url: ${{ secrets.INDEXER_DEV_GOERLI_RPC_URL }}
  #
  indexer_dev_private_key: ${{ secrets.INDEXER_DEV_PRIVATE_KEY }}
  indexer_dev_address: ${{ secrets.INDEXER_DEV_ADDRESS }}
  # OPERATOR DEV rpc endpoints
  operator_dev_avalancheTestnet_rpc_url: ${{ secrets.OPERATOR_DEV_FUJI_RPC_URL }}
  operator_dev_polygonTestnet_rpc_url: ${{ secrets.OPERATOR_DEV_MUMBAI_RPC_URL }}
  operator_dev_ethereumTestnetGoerli_rpc_url: ${{ secrets.OPERATOR_DEV_GOERLI_RPC_URL }}
  #
  operator_dev_private_key: ${{ secrets.OPERATOR_DEV_PRIVATE_KEY }}
  operator_dev_address: ${{ secrets.OPERATOR_DEV_ADDRESS }}

on:
  push:
    branches:
      - 'holocli'
      # Excluded branches
      - '!testnet'
      - '!main'
      - '!mainnet'
      - '!master'

jobs:
  deploy-to-staging:

    name: Deploy-to-staging[dev]
    runs-on: ubuntu-latest

    steps:
#      - name: Use Githubs federated identity with AWS
#        uses: aws-actions/configure-aws-credentials@v1
#        with:
#          role-to-assume: ${{ env.IAM_ROLE }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Checkout code
#        uses: actions/checkout@v2
#
#      - name: Login to ECR
#        id: login-ecr
#        uses: aws-actions/amazon-ecr-login@v1
#
#      - name: Build image
#        run: |
#          docker build --platform linux/amd64 --build-arg AWS_ECR_URL=${{ steps.login-ecr.outputs.registry }} \
#          -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEV_IMAGE_TAG }} .
#
#      - name: Push image
#        run: docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEV_IMAGE_TAG }}

      - name: Use Githubs federated identity with AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ env.IAM_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Checkout the code
        uses: actions/checkout@v2

      # This is a separate action that sets up buildx runner
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2

      # So now you can use Actions' own caching!
      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-single-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-single-buildx

      # And make it available for builds
      - name: Build image
        uses: docker/build-push-action@v2
        with:
          context: .
          builder: ${{ steps.buildx.outputs.name }}
          file: Dockerfile
          build-args: AWS_ECR_URL=${{ steps.login-ecr.outputs.registry }}
          platforms : linux/amd64
          tags      : ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.DEV_IMAGE_TAG }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to  : type=local,dest=/tmp/.buildx-cache-new
          push      : true # This would be set to true in a real world deployment scenario.

      # This ugly bit is necessary if you don't want your cache to grow forever
      # until it hits GitHub's limit of 5GB.
      # Temp fix
      # https://github.com/docker/build-push-action/issues/252
      # https://github.com/moby/buildkit/issues/1896
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Configure AWS creds to access EKS
        # TIP: the deployment user must be in the masters group in the aws-auth config map in the cluster
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ env.AWS_KEY_ID }} #notice: unique for each env
          aws-secret-access-key: ${{ env.AWS_ACCESS_KEY }} #notice: unique for each env
          aws-region: ${{ env.AWS_REGION }}
      #
      - name: Create ns [${{ env.STG_COMMON_NAMESPACE }}]
        uses: tensor-hq/eksctl-helm-action@main
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            kubectl create namespace ${{ env.STG_COMMON_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      #
      #
      # NOTICE: --- INDEXER ---
      - name: Pull the holograph-indexer helm chart version x.x.x from ECR
        shell: bash
        env:
          #
          CHART_REPO: holo-indexer
          CHART_VERSION: ${{ env.STG_HOLOGRAPH_INDEXER_HELM_CHART_VERSION }}
          #
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          helm pull oci://$ECR_REGISTRY/$CHART_REPO --version $CHART_VERSION
      ######
      - name: -> Deploy INDEXER cli in staging [namespace -> ${{ env.STG_COMMON_NAMESPACE }}]
        uses: tensor-hq/eksctl-helm-action@main
        env:
          RELEASE_NAME: ${{ env.INDEXER_RELEASE_NAME }} # notice
          #
          ENABLE_DEBUG: 'true'
          HEALTHCHECK: 'true'
          MODE: 'auto'
          ENABLE_UNSAFE: 'false'
          NETWORK: 'fuji mumbai goerli'
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            helm upgrade --install $RELEASE_NAME \
            holo-indexer-${{ env.STG_HOLOGRAPH_INDEXER_HELM_CHART_VERSION }}.tgz \
            -n ${{ env.STG_COMMON_NAMESPACE }} \
            \
            --set image.repository=${{ env.ECR_REPOSITORY }} \
            --set image.image_tag=${{ env.DEV_IMAGE_TAG }} \
            --set config_file_data=${{ env.INDEXER_HOLOGRAPH_CONFIG_FILE_DATA }} \
            --set holo_indexer_password=${{ env.STG_HOLOGRAPH_INDEXER_PASSWORD }} \
            --set HOLO_INDEXER_HOST=${{ env.STG_HOLOGRAPH_INDEXER_HOST }} \
            --set OPERATOR_API_KEY=${{ env.STG_HOLOGRAPH_INDEXER_OPERATOR_API_KEY }} \
            --set HOLOGRAPH_ENVIRONMENT=${{ env.HOLOGRAPH_ENVIRONMENT }} \
            \
            --set ENABLE_DEBUG=$ENABLE_DEBUG \
            --set HEALTHCHECK=$HEALTHCHECK \
            --set MODE=$MODE \
            --set NETWORK="${NETWORK}" \
            --set ENABLE_UNSAFE="${ENABLE_UNSAFE}" \
            \
            --set dev_rpc_config_values.avalancheTestnet_rpc_url=${{ env.indexer_dev_avalancheTestnet_rpc_url }} \
            --set dev_rpc_config_values.polygonTestnet_rpc_url=${{ env.indexer_dev_polygonTestnet_rpc_url }} \
            --set dev_rpc_config_values.ethereumTestnetGoerli_rpc_url=${{ env.indexer_dev_ethereumTestnetGoerli_rpc_url }} \
            \
            --set dev_rpc_config_values.private_key=${{ env.indexer_dev_private_key }} \
            --set dev_rpc_config_values.address=${{ env.indexer_dev_address }} \
            --set testnet_rpc_config_values.version="beta3" \
            \
            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
            --set datadog_tags.service=$RELEASE_NAME \
            --set datadog_tags.version=chart-${{ env.STG_HOLOGRAPH_INDEXER_HELM_CHART_VERSION }} \
            \
            --set autoscaling.minReplicas=1 \
            --set autoscaling.maxReplicas=1 \
            \
            --values .github/values_for_stg_alb_ingress.yaml \
            --set ingress.annotations."alb\.ingress\.kubernetes\.io/certificate-arn"='${{ env.ALB_CERT_ARN }}' \
            --set ingress.ingress_name=ing-$RELEASE_NAME-health \
            --set ingress.host=$RELEASE_NAME-health.${{ env.STG_DOMAIN }} \
            --set ingress.target_svc_name=$RELEASE_NAME-holo-indexer

#      #
#      #
#      # NOTICE: --- OPERATOR ---
#      - name: Pull the holograph-operator helm chart version x.x.x from ECR
#        shell: bash
#        env:
#          #
#          CHART_REPO: holo-operator
#          CHART_VERSION: ${{ env.STG_HOLOGRAPH_OPERATOR_HELM_CHART_VERSION }}
#          #
#          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#        run: |
#          helm pull oci://$ECR_REGISTRY/$CHART_REPO --version $CHART_VERSION
#      ######
#      - name: -> Deploy OPERATOR cli in staging [namespace -> ${{ env.STG_COMMON_NAMESPACE }}]
#        uses: tensor-hq/eksctl-helm-action@main
#        env:
#          RELEASE_NAME: ${{ env.OPERATOR_RELEASE_NAME }} # notice
#          #
#          ENABLE_DEBUG: 'true'
#          ENABLE_SYNC: 'true'
#          HEALTHCHECK: 'true'
#          MODE: 'auto'
#          ENABLE_UNSAFE: 'false'
#        with:
#          eks_cluster: ${{ env.CLUSTER_NAME }}
#          command: |-
#            helm upgrade --install $RELEASE_NAME \
#            holo-operator-${{ env.STG_HOLOGRAPH_OPERATOR_HELM_CHART_VERSION }}.tgz \
#            -n ${{ env.STG_COMMON_NAMESPACE }} \
#            \
#            --set image.repository=${{ env.ECR_REPOSITORY }} \
#            --set image.image_tag=${{ env.DEV_IMAGE_TAG }} \
#            --set config_file_data=${{ env.OPERATOR_HOLOGRAPH_CONFIG_FILE_DATA }} \
#            --set holo_operator_password=${{ env.STG_HOLOGRAPH_OPERATOR_PASSWORD }} \
#            --set HOLOGRAPH_ENVIRONMENT=${{ env.HOLOGRAPH_ENVIRONMENT }} \
#            \
#            --set ENABLE_DEBUG=$ENABLE_DEBUG \
#            --set ENABLE_SYNC=$ENABLE_SYNC \
#            --set HEALTHCHECK=$HEALTHCHECK \
#            --set MODE=$MODE \
#            --set ENABLE_UNSAFE="${ENABLE_UNSAFE}" \
#            \
#            --set dev_rpc_config_values.avalancheTestnet_rpc_url=${{ env.operator_dev_avalancheTestnet_rpc_url }} \
#            --set dev_rpc_config_values.polygonTestnet_rpc_url=${{ env.operator_dev_polygonTestnet_rpc_url }} \
#            --set dev_rpc_config_values.ethereumTestnetGoerli_rpc_url=${{ env.operator_dev_ethereumTestnetGoerli_rpc_url }} \
#            \
#            --set dev_rpc_config_values.private_key=${{ env.operator_dev_private_key }} \
#            --set dev_rpc_config_values.address=${{ env.operator_dev_address }} \
#            \
#            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
#            --set datadog_tags.service=$RELEASE_NAME \
#            --set datadog_tags.version=chart-${{ env.STG_HOLOGRAPH_OPERATOR_HELM_CHART_VERSION }} \
#            \
#            --values .github/values_for_stg_alb_ingress.yaml \
#            --set ingress.annotations."alb\.ingress\.kubernetes\.io/certificate-arn"='${{ env.ALB_CERT_ARN }}' \
#            --set ingress.ingress_name=ing-$RELEASE_NAME-health \
#            --set ingress.host=$RELEASE_NAME-health.${{ env.STG_DOMAIN }} \
#            --set ingress.target_svc_name=$RELEASE_NAME-holo-operator \
#            --set ingress.blue_green_deployment=false
#
#      - name: -> Info for the new deployments
#        uses: tensor-hq/eksctl-helm-action@main
#        env:
#          INDEXER_RELEASE_NAME : ${{ env.INDEXER_RELEASE_NAME }}
#          OPERATOR_RELEASE_NAME: ${{ env.OPERATOR_RELEASE_NAME }}
#          LB_URL: 'https://staging-alb-1490082055.us-west-2.elb.amazonaws.com'
#        with:
#          eks_cluster: ${{ env.CLUSTER_NAME }}
#          command: |-
#            echo "------------------------- Last n Helm releases -------------------------"
#            echo "--INDEXER--"
#            helm history $INDEXER_RELEASE_NAME  -n ${{ env.STG_COMMON_NAMESPACE }} --max 3
#            echo "--OPERATOR--"
#            helm history $OPERATOR_RELEASE_NAME -n ${{ env.STG_COMMON_NAMESPACE }} --max 3
#
#            echo "------------------------ Newly deployed image [same for all apps] ------------------------"
#            echo "$DEV_IMAGE_TAG"
#
#            echo "------------------------ Healthchecks ------------------------"
#            sleep 55
#
#            ENDPOINT=$INDEXER_RELEASE_NAME-health.${{ env.STG_DOMAIN }}
#            echo "curl -k -H \"Host: $ENDPOINT\" $LB_URL/healthcheck"
#            curl -k -H "Host: $ENDPOINT" $LB_URL/healthcheck | jq '.status'
#
#            ENDPOINT=$OPERATOR_RELEASE_NAME-health.${{ env.STG_DOMAIN }}
#            echo "curl -k -H \"Host: $ENDPOINT\" $LB_URL/healthcheck"
#            curl -k -H "Host: $ENDPOINT" $LB_URL/healthcheck | jq '.status'


#  datadog-log-checks:
#      #####
#      needs: [deploy-to-staging]
#      name: datadog-log-checks
#      runs-on: ubuntu-latest
#      #####
#      env:
#        DD_API_KEY: ${{ secrets.STAGING_DD_API_KEY }}
#        DD_APPLICATION_KEY: ${{ secrets.PYTHON_TESTS_DD_APPLICATION_KEY }}
#        #
#        CHECK_TIMEFRAME: 5 # in minutes
#        RUN_FOR: 5 # in minutes
#
#      steps:
#        - name: Sanitize the branch name to use with Helm
#          id: sanitized_branch
#          shell: bash
#          # replaces '/' to '-' , '_' to '-' , uppercase to lowercase
#          run: echo "##[set-output name=branch;]$( echo ${GITHUB_REF_NAME} | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]' )"
#
#        - name: Checkout tests repo
#          uses: actions/checkout@v3
#          with:
#            repository: holographxyz/qa
#            ref  : main  # notice: main/wip
#            token: ${{ secrets.HOLOGRAPH_GITHUB_PERSONAL_ACCESS_TOKEN }}  # reminder -> created in my personal GH account
#            path : './'
#
#        - name: Setup python
#          uses: actions/setup-python@v2
#          with:
#            python-version: 3.8
#
#        - name: Install Python packages
#          run : |
#            python -m pip install datadog_api_client
#
#        - name: Check Datadog monitor for -> Too Many Pod Restarts [indexer]
#          env:
#            ENV: ${{ env.CLUSTER_NAME }}
#            RELEASE_NAME: "indexer-boo"
#          run: |
#            python python_api_tests/test_dd_k8s_holocli_TooManyRestarts.py
#
#        - name: Check Datadog monitor for -> Too Many Pod Restarts [operator]
#          env:
#            ENV: ${{ env.CLUSTER_NAME }}
#            RELEASE_NAME: "operator-boo"
#          run: |
#            python python_api_tests/test_dd_k8s_holocli_TooManyRestarts.py
#
##        - name: Check Datadog monitor for -> ImgPullBackoff
##          env:
##            ENV: ${{ env.CLUSTER_NAME }}
##            BRANCH_NAME: ${{ steps.sanitized_branch.outputs.branch }} # this is the namespace
##            CHECK_TIMEFRAME: 5 # in minutes
##            RUN_FOR: 5 # in minutes
##            APP: "indexer" # todo - for operator & propagator
##          run: |
##            python python_api_tests/test_dd_k8s_ImgPullBackoff.py
