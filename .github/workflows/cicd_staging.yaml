name: Deploy holoclis to staging

permissions:
  id-token: write
  contents: read   # This is required for actions/checkout@v2

env:
  AWS_REGION    : us-west-2
  IAM_ROLE      : arn:aws:iam::177635894328:role/Github_role_to_access_ECR
  ECR_REPOSITORY: holo-cli-dev # notice: the same for all 3 cli apps
  #
  DEV_IMAGE_TAG : dev-a7474875986900258b3f4e6085a971b669d3b22d #dev-${{ github.sha }} #NOTICE
  #
  STG_HOLO_INDEXER_HELM_CHART_VERSION   : 0.0.8 # NOTICE
  STG_HOLO_OPERATOR_HELM_CHART_VERSION  : 0.0.7 # NOTICE
  STG_HOLO_PROPAGATOR_HELM_CHART_VERSION: 0.0.7 # NOTICE
  #
  CLUSTER_NAME   : staging
  AWS_KEY_ID     : ${{ secrets.NEWSTAGE_USER_AWS_ACCESS_KEY_ID }}
  AWS_ACCESS_KEY : ${{ secrets.NEWSTAGE_USER_AWS_SECRET_ACCESS_KEY }}
  #
  #TODO - create new gh secret for prod. should be different from staging????
  STG_HOLO_INDEXER_OPERATOR_API_KEY: ${{ secrets.HOLO_INDEXER_OPERATOR_API_KEY }}
  # TODO -> HOLO_INDEXER_HOST <----- replace with k8s service endpoint [angello,alex should make code chamges]
  STG_HOLO_INDEXER_HOST: https://develop.cxipchain.xyz
  #
  # TODO -> set the password as github secret var
  STG_HOLO_INDEXER_PASSWORD   : d82aFsZdmtVxpWMJLpJu #TODO ${{ secrets.HOLO_INDEXER_PASSWORD }}
  STG_HOLO_OPERATOR_PASSWORD  : d82aFsZdmtVxpWMJLpJu #TODO ${{ secrets.HOLO_OPERATOR_PASSWORD }}
  STG_HOLO_PROPAGATOR_PASSWORD: d82aFsZdmtVxpWMJLpJu #TODO ${{ secrets.HOLO_PROPAGATOR_PASSWORD }}
  #
  # switching between the keys in the config map
  HOLO_CONFIG_FILE_DATA: stg-config-file # [stg-config-file/prod-config-file]
  #
#  STG_COMMON_NAMESPACE: holocli
  STG_COMMON_NAMESPACE: testholo #deleteme
  STG_DOMAIN: "cxipchain.xyz"

on:
  push:
    branches:
      - 'holocli'  #deleteme
#      - 'develop' # notice: the actual staging branch -> [the deployment is happening into the holocli namespace!]
      #
      - '!main'     # EXCLUDES this branch
      - '!master'   # EXCLUDES this branch

jobs:
  deploy-to-new-staging:
    name: deploy-to-staging
    runs-on: ubuntu-latest

    steps:
      - name: Use Githubs federated identity with AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ env.IAM_ROLE }}
          aws-region    : ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Checkout code
        uses: actions/checkout@v2

#      - name: Build and push image to ECR
#        env:
#          ECR_REGISTRY  : ${{ steps.login-ecr.outputs.registry }}
#          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
#        run: |
#          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$DEV_IMAGE_TAG .
#          docker push     $ECR_REGISTRY/$ECR_REPOSITORY:$DEV_IMAGE_TAG

      - name: Configure AWS creds to access EKS
        # notice: TIP: the deployment user must be in the masters group in the aws-auth config map in the cluster
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id    : ${{ env.AWS_KEY_ID }}     #notice: unique for each env
          aws-secret-access-key: ${{ env.AWS_ACCESS_KEY }} #notice: unique for each env
          aws-region           : ${{ env.AWS_REGION }}

      - name: Create holocli dev ns
        uses: tensor-hq/eksctl-helm-action@main
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            kubectl create namespace ${{ env.STG_COMMON_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      #
      #
      # NOTICE: --- INDEXER ---
      - name: Pull the holo-indexer helm chart version x.x.x from ECR
        shell: bash
        env:
          #
          CHART_REPO   : holo-indexer
          CHART_VERSION: ${{ env.STG_HOLO_INDEXER_HELM_CHART_VERSION }}
          #
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run : |
          helm pull oci://$ECR_REGISTRY/$CHART_REPO --version $CHART_VERSION

      - name: -> Deploy INDEXER cli in staging [namespace -> ${{ steps.STG_COMMON_NAMESPACE }}]
        uses: tensor-hq/eksctl-helm-action@main
        env:
          RELEASE_NAME: indexer-dev
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            helm upgrade --install $RELEASE_NAME \
            holo-indexer-${{ env.STG_HOLO_INDEXER_HELM_CHART_VERSION }}.tgz \
            -n ${{ env.STG_COMMON_NAMESPACE }} \
            --set image.repository=${{ env.ECR_REPOSITORY }} \
            --set image.image_tag=${{ env.DEV_IMAGE_TAG }} \
            --set config_file_data=${{ env.HOLO_CONFIG_FILE_DATA }} \
            --set holo_indexer_password=${{ env.STG_HOLO_INDEXER_PASSWORD }} \
            --set HOLO_INDEXER_HOST=${{ env.STG_HOLO_INDEXER_HOST }} \
            --set OPERATOR_API_KEY=${{ env.STG_HOLO_INDEXER_OPERATOR_API_KEY }} \
            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
            --set datadog_tags.service=$RELEASE_NAME-holo-indexer \
            --set datadog_tags.version=chart-${{ env.STG_HOLO_INDEXER_HELM_CHART_VERSION }} \
            --values .github/values_for_stg_alb_ingress.yaml \
            --set ingress.ingress_name=ing-$RELEASE_NAME-health \
            --set ingress.host=$RELEASE_NAME-health.${{ env.STG_DOMAIN }} \
            --set ingress.target_svc_name=$RELEASE_NAME-holo-indexer \
            --set ingress.blue_green_deployment=no
      #
      #
      # NOTICE: --- OPERATOR ---
      - name: Pull the holo-operator helm chart version x.x.x from ECR
        shell: bash
        env:
          #
          CHART_REPO   : holo-operator
          CHART_VERSION: ${{ env.STG_HOLO_OPERATOR_HELM_CHART_VERSION }}
          #
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run : |
          helm pull oci://$ECR_REGISTRY/$CHART_REPO --version $CHART_VERSION

      - name: -> Deploy OPERATOR cli in staging [namespace -> ${{ env.STG_COMMON_NAMESPACE }}]
        uses: tensor-hq/eksctl-helm-action@main
        env:
          RELEASE_NAME: operator-dev
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            helm upgrade --install $RELEASE_NAME \
            holo-operator-${{ env.STG_HOLO_OPERATOR_HELM_CHART_VERSION }}.tgz \
            -n ${{ env.STG_COMMON_NAMESPACE }} \
            --set image.repository=${{ env.ECR_REPOSITORY }} \
            --set image.image_tag=${{ env.DEV_IMAGE_TAG }} \
            --set config_file_data=${{ env.HOLO_CONFIG_FILE_DATA }} \
            --set holo_operator_password=${{ env.STG_HOLO_OPERATOR_PASSWORD }} \
            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
            --set datadog_tags.service=$RELEASE_NAME-holo-operator \
            --set datadog_tags.version=chart-${{ env.STG_HOLO_OPERATOR_HELM_CHART_VERSION }} \
            --values .github/values_for_stg_alb_ingress.yaml \
            --set ingress.ingress_name=ing-$RELEASE_NAME-health \
            --set ingress.host=$RELEASE_NAME-health.${{ env.STG_DOMAIN }} \
            --set ingress.target_svc_name=$RELEASE_NAME-holo-operator \
            --set ingress.blue_green_deployment=no
      #
      #
      # NOTICE: --- PROPAGATOR ---
      - name: Pull the holo-propagator helm chart version x.x.x from ECR
        shell: bash
        env:
          #
          CHART_REPO   : holo-propagator
          CHART_VERSION: ${{ env.STG_HOLO_PROPAGATOR_HELM_CHART_VERSION }}
          #
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run : |
          helm pull oci://$ECR_REGISTRY/$CHART_REPO --version $CHART_VERSION

      - name: -> Deploy PROPAGATOR cli in staging [namespace -> ${{ env.STG_COMMON_NAMESPACE }}]
        uses: tensor-hq/eksctl-helm-action@main
        env:
          RELEASE_NAME: propagator-dev
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            helm upgrade --install $RELEASE_NAME \
            holo-propagator-${{ env.STG_HOLO_PROPAGATOR_HELM_CHART_VERSION }}.tgz \
            -n ${{ env.STG_COMMON_NAMESPACE }} \
            --set image.repository=${{ env.ECR_REPOSITORY }} \
            --set image.image_tag=${{ env.DEV_IMAGE_TAG }} \
            --set config_file_data=${{ env.HOLO_CONFIG_FILE_DATA }} \
            --set holo_propagator_password=${{ env.STG_HOLO_PROPAGATOR_PASSWORD }} \
            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
            --set datadog_tags.service=$RELEASE_NAME-holo-propagator \
            --set datadog_tags.version=chart-${{ env.STG_HOLO_PROPAGATOR_HELM_CHART_VERSION }} \
            --values .github/values_for_stg_alb_ingress.yaml \
            --set ingress.ingress_name=ing-$RELEASE_NAME-health \
            --set ingress.host=$RELEASE_NAME-health.${{ env.STG_DOMAIN }} \
            --set ingress.target_svc_name=$RELEASE_NAME-holo-propagator \
            --set ingress.blue_green_deployment=no

      - name: -> Info for the new deployments
        uses: tensor-hq/eksctl-helm-action@main
        env:
          INDEXER_RELEASE_NAME   : indexer-dev
          OPERATOR_RELEASE_NAME  : operator-dev
          PROPAGATOR_RELEASE_NAME: propagator-dev
          LB_URL: staging-alb-1490082055.us-west-2.elb.amazonaws.com
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          command: |-
            echo "------------------------- Last 5 Helm releases -------------------------"
            echo "--INDEXER--"
            helm history $INDEXER_RELEASE_NAME    -n ${{ env.STG_COMMON_NAMESPACE }} --max 3
            echo "--OPERATOR--"
            helm history $OPERATOR_RELEASE_NAME   -n ${{ env.STG_COMMON_NAMESPACE }} --max 3
            echo "--PROPAGATOR--"
            helm history $PROPAGATOR_RELEASE_NAME -n ${{ env.STG_COMMON_NAMESPACE }} --max 3

            echo "------------------------ Newly deployed image [same for all 3 apps] ------------------------"
            echo "$DEV_IMAGE_TAG"

            echo "------------------------ Healthchecks ------------------------"
            ENDPOINT=$INDEXER_RELEASE_NAME-health.${{ env.STG_DOMAIN }}
            echo "curl -k -H \"Host: $ENDPOINT\" https://$LB_URL/healthcheck"
            curl -k -H "Host: $ENDPOINT" https://$LB_URL/healthcheck | jq '.status'

            ENDPOINT=$OPERATOR_RELEASE_NAME-health.${{ env.STG_DOMAIN }}
            echo "curl -k -H \"Host: $ENDPOINT\" https://$LB_URL/healthcheck"
            curl -k -H "Host: $ENDPOINT" https://$LB_URL/healthcheck | jq '.status'

            ENDPOINT=$PROPAGATOR_RELEASE_NAME-health.${{ env.STG_DOMAIN }}
            echo "curl -k -H \"Host: $ENDPOINT\" https://$LB_URL/healthcheck"
            curl -k -H "Host: $ENDPOINT" https://$LB_URL/healthcheck | jq '.status'
