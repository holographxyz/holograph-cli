name: Deploy to -new- staging

permissions:
  id-token: write
  contents: read   # This is required for actions/checkout@v2

env:
  AWS_REGION    : us-west-2
  IAM_ROLE      : arn:aws:iam::177635894328:role/Github_role_to_access_ECR
  ECR_REPOSITORY: holo-operator-dev
  #
  DEV_IMAGE_TAG : dev-02708e8a0f82ba9004628494651f0539a529b690 #dev-${{ github.sha }} #notice:!!!!!! <------------------
  #
#  STG_HOLO_OPERATOR_HELM_CHART_VERSION: #TODO # NOTICE: <-----------------------------------------
  #
  CLUSTER_NAME   : staging
  AWS_KEY_ID     : ${{ secrets.NEWSTAGE_USER_AWS_ACCESS_KEY_ID }}
  AWS_ACCESS_KEY : ${{ secrets.NEWSTAGE_USER_AWS_SECRET_ACCESS_KEY }}

on:
  push:
    branches:
      - 'holo-cli-operator' #deleteme
#      - 'develop' # notice: the actual staging branch
      #
#      - 'feat/*'    # matches every branch containing 'feat/'
#      - 'feature/*' # matches every branch containing 'feature/'
#      - 'hotfix/*'  # matches every branch containing 'hotfix/'
      #
      - '!main'     # EXCLUDES this branch
      - '!master'   # EXCLUDES this branch

jobs:
  deploy-to-new-staging:
    name: deploy-to-new-staging
    runs-on: ubuntu-latest

    steps:
      - name: Sanitize the branch name to use with Helm
        id: sanitized_branch
        shell: bash
        run: echo "##[set-output name=branch;]$(echo ${GITHUB_REF_NAME} | tr '/' '-' )"

      - name: Use Githubs federated identity with AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ env.IAM_ROLE }}
          aws-region    : ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Checkout code
        uses: actions/checkout@v2

#      - name: Pull the holo-operator helm chart version x.x.x from ECR
#        shell: bash
#        env:
#          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#        run : |
#          helm pull oci://$ECR_REGISTRY/nest-api --version ${{ env.STG_HOLO_OPERATOR_HELM_CHART_VERSION }}

#      - name: Build and push image to ECR
#        env:
#          ECR_REGISTRY  : ${{ steps.login-ecr.outputs.registry }}
#          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
#        run: |
#          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$DEV_IMAGE_TAG .
#          docker push     $ECR_REGISTRY/$ECR_REPOSITORY:$DEV_IMAGE_TAG

      - name: Configure AWS creds to access EKS
        # notice: TIP: the deployment user must be in the masters group in the aws-auth config map in the cluster
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id    : ${{ env.AWS_KEY_ID }}     #notice: unique for each env
          aws-secret-access-key: ${{ env.AWS_ACCESS_KEY }} #notice: unique for each env
          aws-region           : ${{ env.AWS_REGION }}

      - name: ---> Deploy holo-operator in staging cluster [branch -> ${{ steps.sanitized_branch.outputs.branch }}]<--
        uses: tensor-hq/eksctl-helm-action@main
        env:
          BRANCH_NAME : ${{ steps.sanitized_branch.outputs.branch }}
          RELEASE_NAME: holo-op-dev # Notice <------------------------------[here you control blue-green deployments]
        with:
          eks_cluster: ${{ env.CLUSTER_NAME }}
          # todo -> set the vars in a separate workflow step
          command: |-
            helm ls
#            echo "Notice: Set the HPA based on the branch..."
#            if [[ $BRANCH_NAME == 'develop' ]]; then
#                export HPA_MIN_REPLICAS=1;
#                export HPA_MAX_REPLICAS=5;
#            else
#                export HPA_MIN_REPLICAS=1;
#                export HPA_MAX_REPLICAS=3;
#            fi
#
#            echo "Notice: Set the -blue_green_deployment- var ..."
#            if [[ $RELEASE_NAME != 'dev' ]]; then
#              blue_green_deployment=yes
#            fi
#
#            helm upgrade --install $RELEASE_NAME holo-operator-${{ env.STG_HOLO_OPERATOR_HELM_CHART_VERSION }}.tgz -n $BRANCH_NAME \
#            --set image.repository=holo-operator-dev \
#            --set image.image_tag=$DEV_IMAGE_TAG --set service.type=ClusterIP \
#            --set NODE_ENV=staging \
#            --set autoscaling.minReplicas=$HPA_MIN_REPLICAS \
#            --set autoscaling.maxReplicas=$HPA_MAX_REPLICAS \
#            --set autoscaling.targetMemoryUtilizationPercentage=90 \
#            --set resources.limits.cpu=300m \
#            --set resources.limits.memory=400Mi \
#            --set resources.requests.cpu=100m \
#            --set resources.requests.memory=200Mi \
#            --set datadog_tags.env=${{ env.CLUSTER_NAME }} \
#            --set datadog_tags.service=$BRANCH_NAME-$RELEASE_NAME-holo-operator \
#            --set datadog_tags.version=v.0.0.0 \
#            --values .github/values_for_stg_alb_ingress.yaml \
#            --set ingress.ingress_name=ing-$BRANCH_NAME-$RELEASE_NAME \
#            --set ingress.host=$BRANCH_NAME.$DOMAIN \
#            --set ingress.target_svc_name=$RELEASE_NAME-holo-operator \
#            --set ingress.blue_green_deployment=$blue_green_deployment
#
#            echo 'HELM_RELEASES<<EOF' >> $GITHUB_ENV
#            echo "$(helm history $RELEASE_NAME -n $BRANCH_NAME --max 5)" >> $GITHUB_ENV
#            echo 'EOF' >> $GITHUB_ENV
#
#            echo "ENDPOINT=$BRANCH_NAME.$DOMAIN" >> $GITHUB_ENV
#            echo "RELEASE_NAME=$RELEASE_NAME" >> $GITHUB_ENV
#
#            if [[ $RELEASE_NAME == '.....' ]]; then
#              echo "Notice: Annotate the -blue- ingress so the main route should be the last to be evaluated, hence the max number 1000"
#              kubectl annotate ingress --overwrite=true -n $BRANCH_NAME ing-$BRANCH_NAME-$RELEASE_NAME alb.ingress.kubernetes.io/group.order='1000'
#            fi
#
#            if [[ $RELEASE_NAME != '...' ]]; then
#              echo "Notice: Annotate the -green- ingress so it gets all the requests with specific headers..."
#              HEADER_KEY=color
#              HEADER_VALUE=green
#              echo "HEADER_KEY=$HEADER_KEY"     >> $GITHUB_ENV
#              echo "HEADER_VALUE=$HEADER_VALUE" >> $GITHUB_ENV
#
#              kubectl annotate ingress --overwrite=true -n $BRANCH_NAME ing-$BRANCH_NAME-$RELEASE_NAME alb.ingress.kubernetes.io/actions.blue-green=\{\"type\":\"forward\",\"forwardConfig\":\{\"targetGroups\":\[\{\"serviceName\":\"$RELEASE_NAME-nest-api\",\"servicePort\":443}]\}\}
#              kubectl annotate ingress --overwrite=true -n $BRANCH_NAME ing-$BRANCH_NAME-$RELEASE_NAME alb.ingress.kubernetes.io/conditions.blue-green=\[\{\"field\":\"http-header\",\"httpHeaderConfig\":\{\"httpHeaderName\":\"$HEADER_KEY\",\"values\":\[\"$HEADER_VALUE\"\]\}\}\]
#            fi

#      - name: ---> Info for the New Deployment <---
#        run: |
#          echo "------------------------- Last 5 Helm releases -------------------------"
#          echo "${{ env.HELM_RELEASES }}"
#          echo "------------------------- Newly deployed image ------------------------- "
#          echo "$DEV_IMAGE_TAG"
#          echo "------------------------- Dev api endpoint ------------------------- "
#          echo "$ENDPOINT"
#          echo
#          echo "Patience you must have...my young padawan..."
#          sleep 20
#          echo "------------------------- Test the endpoint /v1/health -------------------------"
#
#          if [[ ${{env.RELEASE_NAME}} == '...' ]]; then
#            echo "curl -k -i -H \"Host: $ENDPOINT\" https://$LB_URL/v1/health"
#            curl -k -H "Host: $ENDPOINT" https://$LB_URL/v1/health
#          else
#            echo "curl -k -i -H \"$HEADER_KEY: $HEADER_VALUE\" -H \"Host: $ENDPOINT\" https://$LB_URL/v1/health"
#            curl -k -H "$HEADER_KEY: $HEADER_VALUE" -H "Host: $ENDPOINT" https://$LB_URL/v1/health
#          fi
